/***************************************************************************
 *   Copyright (C) 2007 by Mark Nevill                                     *
 *   mark.nevill@gmail.com                                                 *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#include "iniparser.h"
#include <QFile>
#include <QTextStream>
#include <QSet>
#include "stacktrace.h"

namespace ini
{

	static const char COMMENT_BEGIN = ';';
	static const char ASSIGNER = '=';
	static const char SECTION_NAME_BEGIN = '[';
	static const char SECTION_NAME_END = ']';

	void readData(const QString& filename, AttributeMap& data) throw(ParseError, Exception)
	{
		FNTRACE("ini", "", "readData", QString("%1, %2 rows of data").arg(filename).arg(data.size()));

		QFile file(filename);
		if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
			ETHROW(Exception(QString("Unable to open %1 for reading.").arg(filename)));

		QByteArray line;
		size_t lineNumber = 0;

		while (!file.atEnd()) {

			line = file.readLine();
			++lineNumber;

			// trim comments and whitespace
			if (line.isEmpty()) continue;
			if (line.contains(COMMENT_BEGIN))
				line.truncate(line.indexOf(COMMENT_BEGIN));
			if (line.isEmpty()) continue;
			line = line.trimmed();
			if (line.isEmpty()) continue;

			// name=value pair?
			else if (line.contains(ASSIGNER))
			{
				QString name = line.left(line.indexOf(ASSIGNER));
				name = name.trimmed();
				if (name.isEmpty())
					ETHROW(ParseError(filename, lineNumber, "Empty name left of assigner."));
				QString value = line.right(line.length() - line.indexOf(ASSIGNER) - 1);
				value = value.trimmed();
				data[name] = value;
			}
			else
				ETHROW(ParseError(filename, lineNumber, "Unknown non-empty line."));
		}
	}

	void writePreserving(QFile& inFile, QTextStream& out, const AttributeMap& data)
	{
		FNTRACE("ini", "", "writePreserving", QString("in, out, %1 rows of data").arg(data.size()));

		int i, j;
		QChar c;
		QString name;
		size_t lineNumber = 0;
		QString line;
		typedef QSet<AttributeMap::key_type> KeySet;
		KeySet unwrittenKeys = KeySet::fromList(data.keys());

		if (!inFile.open(QIODevice::ReadOnly | QIODevice::Text))
			ETHROW(Exception(QString("Unable to open %1 for reading.").arg(inFile.fileName())));
		QTextStream in(&inFile);

		while (!(line = in.readLine()).isNull())
		{
			++lineNumber;
			//std::cout << lineNumber << ": " << line.toStdString() << ":\n";

			for (i = 0; line[i].isSpace(); ++i) { out << line[i]; }

			if (line[i].isNull()) { out << '\n'; continue; }
			else if (line[i] == COMMENT_BEGIN) { out << line.mid(i) << '\n'; continue; }

			for (j = i; !(c = line[i]).isNull() && c!=COMMENT_BEGIN && c!=ASSIGNER; ++i) ;
			//std::cout << "non-empty, ";
			if (c != ASSIGNER) // non-empty line that isn't assignment -> invalid
				ETHROW(ParseError(inFile.fileName(), lineNumber, "Unknown non-empty line."));
			for (--i; line[i].isSpace(); --i) ; // last character of name
			name = line.mid(j, i - j + 1);
			//std::cout << "name: " << name.toStdString() << ' ';

			for ( ; line[j]!=ASSIGNER; ++j) out << line[j];
			out << ASSIGNER;
			i = j + 1;

			for ( ; line[i].isSpace(); ++i) out << line[i];

			if (data.contains(name))
			{
				//std::cout << "known ";
				out << data.value(name);
				unwrittenKeys.remove(name);
				for (j = i; !line[i].isNull() && line[i]!=COMMENT_BEGIN; ++i) ; // EOL || comment
				for (--i; line[i].isSpace(); --i) ; // last character of value
				++i; // first character after value
			}

			out << line.mid(i) << '\n';
			//std::cout << '\n';
		}

		if (unwrittenKeys.size())
		{
			out << '\n' << COMMENT_BEGIN << "Following lines were generated by Ds1edit Loader:\n";
			for (KeySet::iterator key = unwrittenKeys.begin();
				key != unwrittenKeys.end(); ++key)
				out << (*key) << ' ' << ASSIGNER << ' ' << data.value(*key) << '\n';
		}

		//in.resize(in.pos()+1);
		inFile.close();
	}

	void writeSparse(QFile& file, const AttributeMap& data)
	{
		FNTRACE("ini", "", "writeSparse", QString("file %1, %2 rows of data").arg(file.fileName()).arg(data.size()));

		if (!file.open(QIODevice::WriteOnly | QIODevice::Text | QIODevice::Truncate))
			ETHROW(Exception(QString("Unable to open %1 for writing.").arg(file.fileName())));

		file.resize(0);
		QTextStream fout(&file);

		int max_key_length = 0;
		for (AttributeMap::const_iterator iter = data.begin(); iter != data.end(); ++iter)
		{
			if (iter.key().length() > max_key_length)
				max_key_length = iter.key().length();
		}
		for (AttributeMap::const_iterator iter = data.begin(); iter != data.end(); ++iter)
		{
			fout << iter.key();
			for (int i = iter.key().length(); i < max_key_length; ++i)
				fout << ' ';
			fout << " = " << iter.value() << "\n";
		}
	}

	void writeData(const QString& filename, const QString& defaultFilename,
		const AttributeMap& data, writeMode mode) throw(ParseError, Exception)
	{
		FNTRACE("ini", "", "writeData", QString("%1, %2, %3 rows of data, %4")
			.arg(filename).arg(defaultFilename).arg(data.size()).arg(mode));

		QFile file(filename);
		if (!file.exists())
			ETHROW(Exception(QString("File %1 does not exist.").arg(filename)));

		if (mode == preserve || mode == full)
		{
			QByteArray buf;
			QTextStream out(&buf);

			if (mode == full)
			{
				QFile defini(defaultFilename);
				writePreserving(defini, out, data);
			}
			else
			{
				writePreserving(file, out, data);
			}
			out.setDevice(0);

			if (file.isOpen()) file.close();
			if (!file.open(QIODevice::ReadWrite | QIODevice::Text | QIODevice::Truncate) ||
				!file.isWritable())
				ETHROW(Exception(QString("Unable to open %1 for writing.").arg(filename)));

			//file.resize(0);
			//if (!file.isOpen() || !file.isWritable())
			//	ETHROW(Exception(QString("%1 not writeable after resize.").arg(filename)));
			//file.close();
			/*if (!file.isOpen() || !file.isWritable())
				ETHROW(Exception(QString("%1 not writeable after closeing.").arg(filename)));*/
			//if (!file.open(QIODevice::ReadWrite | QIODevice::Text) || !file.isWritable())
			//	ETHROW(Exception(QString("Unable to open %1 for writing.").arg(filename)));
			/*file.seek(0);
			if (!file.isOpen() || !file.isWritable())
				ETHROW(Exception(QString("%1 not writeable after seek.").arg(filename)));*/
			out.setDevice(&file);
			if (!file.isOpen() || !file.isWritable())
				ETHROW(Exception(QString("%1 not writeable after stream-association.").arg(filename)));
			out << buf << flush;
		}
		else
			writeSparse(file, data);
	}

}
